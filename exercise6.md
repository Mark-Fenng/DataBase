姓名：冯运
学号：1160300524

作业六：事物的处理与恢复

1. 在𝑅(𝑘,𝑎)和𝑆(𝑘,𝑏)两个关系上，有下面两个查询计划A和B
   
   Plan A: $(σ_{a=3}(𝑅)) \Join 𝑆$
   
   Plan B: $σ_{a=3}(𝑅 \Join 𝑆)$
   
   回答下面两个问题：
   
   a. 如果没有𝑅和𝑆上属性值分布的知识，一般情况下你选择哪个执行计划，为什么？

   选择Plan A
   因为先选择之后一般能够减少元组的个数，这样在连接时可以减小连接操作的代价。
   
   b. 是否存在一种情况你会选择另外一个计划，为什么？

   在多次存在$R \Join S$的连接操作时,可以将中间结果保留,从而进行查询优化,如果进行planA,则优化空间较小

2. 考虑如下的三个事务的调度。这是否是一个冲突可串行化调度？请解释一下你的判据。如果是，将它转换成串行调度。

   |  T0   |  T1   |  T2   |
   | :---: | :---: | :---: |
   | r0(A) |       |       |
   | w0(A) |       |       |
   |       |       | r2(A) |
   |       |       | w2(A) |
   |       | r1(A) |       |
   | r0(B) |       |       |
   |       |       | r2(B) |
   | w0(B) |       |       |
   |       |       | w2(B) |
   |       | r1(B) |       |

   不是一个冲突可串行化的调度，构造该调度的优先图如下：

   ![2](./static/transaction.svg)

   如图所示，该优先图中有环，所以该调度不是冲突可串行化的。

3. 用两阶段锁协议保证题目2的调度的冲突可串行化（写出加锁和去锁的过程,可以附上必要的文字说明）

   ```sql
    T0: 
        // getting lock stage
        LOCK_X(A);
        r0(A);
        w0(A);
        LOCK_X(B);
        r0(B);
        w0(B);
        // release lock stage
        UNLOCK(A);
        UNLOCK(B);

    T1: 
        // getting lock stage
        LOCK_S(A);
        r1(A);
        LOCK_S(B);
        r1(B);
        // release lock stage
        UNLOCK(A);
        UNLOCK(B);

    T2: 
        // getting lock stage
        LOCK_X(A);
        r2(A);
        w2(A);
        LOCK_X(B);
        r2(B);
        w2(B);
        // release lock stage
        UNLOCK(A);
        UNLOCK(B);
   ```

4. 考虑两个事务T1，T2。其中，

   T1显示账户A与B的内容：
   
   ```
   T1: Read(B);
       Read(A);
       Display(A+B);
   ```

   T2表示从账户B转50美元到账户A, 然后显示两个账户的内容：
   
   ```
   T2: Read(B);
       B := B-50;
       Write(B);
       Read(A);
       A := A+50;
       Write(A);
       Display(A+B);
   ```

   令 TS(T1)，TS(T2) 分别是事务T1和T2开始的时间戳，并且TS(T2) < TS(T1)。
   
   现有如下一个调度。请给出每一步骤中时间戳 W-ts(A),  R-ts(A), W-ts(B), R-ts(B)的取值。（注：Display(A+B)表示显示账户A和账户B的内容，时间戳若不可知则留为空）

   |      T1      |      T2      | W-ts(A) | R-ts(A) | W-ts(B) | R-ts(B) |
   | :----------: | :----------: | :-----: | :-----: | :-----: | :-----: |
   |              |   Read(B)    |         |         |         |         |
   |              |  B := B-50   |         |         |         | TS(T2)  |
   |              |   Write(B)   |         |         |         | TS(T2)  |
   |   Read(B)    |              |         |         | TS(T2)  | TS(T2)  |
   |              |   Read(A)    |         |         | TS(T2)  | TS(T1)  |
   |              |  A := A+50   |         | TS(T2)  | TS(T2)  | TS(T1)  |
   |   Read(A)    |              |         | TS(T2)  | TS(T2)  | TS(T1)  |
   |              |   Write(A)   |         | TS(T1)  | TS(T2)  | TS(T1)  |
   | Display(A+B) |              |         |         |         |         |
   |              | Display(A+B) |         |         |         |         |

    
    由于在T2在Write(A)时,其时间戳TS(2)<R-ts(A), 其写入的值已经被之后的事物读取,事物T2应该要回滚
   


5.设一个数据库系统启动后中,执行 4 个事务 T0、T1、T2 和 T3。四个事务的内容如下:
T0: A := A + 20 (读入数据库元素 A 的值,加上 20 后,再写回 A 的值)
T1: B := B – 10 (读入数据库元素 B 的值,减去 10 后,再写回 B 的值)
T2: C := C * 2 (读入数据库元素 C 的值,乘以 2 后,再写回 C 的值)
T3: D := D + 15 (读入数据库元素 D 的值,加上 15 后,再写回 D 的值)

除了这四个事务外,系统中无其他事务执行。设四个事务开始前,数据库元素 A、
B、C、D 的值分别为 A = 50,B = 30,C = 35,D = 15。在执行这四个事务的过
程中,系统发生了故障。系统重启后,经故障恢复,数据库元素 A、B、C、D 的
值被恢复为 A = 50,B = 20,C = 70,D = 15。故障恢复时,数据库系统日志
文件中包含如下 12 条日志记录,这里只给出部分日志记录。已知该数据库管理
系统使用基于 undo-redo 日志的故障恢复技术,这段日志中仅有 1 个不停机检查
点(又称模糊检查点)。
|       |                               |
| :---: | :---------------------------: |
|   1   |          <T0, start>          |
|   2   |        <T0, A, 50, 70>        |
|   3   |          <T2, start>          |
|   4   | < start checkpoint (T0, T2) > |
|   5   |      < end checkpoint >       |
|   6   |          <T1, start>          |
|   7   |        <T1, B, 30, 20>        |
|   8   |         <T1, commit>          |
|   9   |        <T2, C, 35, 70>        |
|  10   |          <T3, start>          |
|  11   |        <T3, D, 15, 30>        |
|  12   |         <T2, commit>          |


请根据上述信息,回答下列问题:
a.将日志文件补充完整,直接在上面的日志文件中填写。一个事务 T 启动时向日
志文件中写入日志记录<T, start>;提交时向日志文件中写入日志记录<T,
commit>;中止时向日志文件中写入日志记录<T, abort>;对数据库元素 X 进行修改时向日志文件中写入日志记录<T, X, X 的旧值, X 的新值>。
b.在故障恢复过程中,哪些事务需要 redo,哪些事务需要 undo。说明理由。

T0和T3需要undo,因为T0和T3在日志中没有提交,需要将缓存中T0和T3做过的操作进行撤销,即undo
T1和T2需要redo,因为T1和T2在日志中已经提交,为了保证事物更改同步写会到数据库中,需要redo

c.在故障恢复过程中,还会向日志文件添加什么日志记录?说明理由。

可能需要向其中添加 undo(T0),undo(T3), redo(T1), redo(T2)的记录
同时可能向其中添加<T0, abort>和<T3, abort>,表示在故障发生时,T0和T3发生了中断,需要撤销